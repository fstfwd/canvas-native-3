#!/usr/bin/env node

'use strict';

/* eslint-env node */

require('babel-register');

const CONSTANTS = require('../lib/constants.json');
const FS        = require('fs');
const Hbs       = require('handlebars');
const Path      = require('path');
const YAML      = require('yamljs');
const _         = require('lodash');
const assert    = require('assert');

const SEPARATOR = CONSTANTS.READABLE_SEPARATOR;

const types       = YAML.load(Path.join(__dirname, '../docs/types.yaml'));
const overviewTpl = Hbs.compile(
  FS.readFileSync(Path.join(__dirname, '../docs/overview.md.hbs')).toString());
const overview    = overviewTpl({ SEPARATOR: SEPARATOR });

// Validate that typeKeys are unique
assert.equal(types.length, _.compact(_.uniqBy(types, 'typeKey')).length);

let typesMarkdown = '';
for (const type of types) {
  typesMarkdown += makeString(4, `
    ### ${type.title}

    ${type.description}
    #### Parameters

    ${formatParameters(type.parameters)}
    #### Example

    ${formatExamples(type)}

    ---`) + '\n\n';
}

FS.writeFileSync(Path.join(__dirname, '../README.md'),
   overview
    .concat('\n')
    .concat(typesMarkdown));

function buildNative(type) {
  return makeString(4, `
    ##### Native

    \`\`\`
    ${type.typeKey}${SEPARATOR}${buildNativeParameters(type.parameters)}${SEPARATOR}Foo bar
    \`\`\``);
}

function buildNativeParameters(parameters) {
  if (!parameters) {
    return '';
  }

  let native = {};
  if (parameters.required) {
    for (const parameter of parameters.required) {
      native[parameter.name] = parameter.example || buildNativeParameterValue(parameter);
    }
  }

  if (parameters.optional) {
    for (const parameter of parameters.optional) {
      native[parameter.name] = parameter.example || buildNativeParameterValue(parameter);
    }
  }

  return JSON.stringify(native);
}

function buildNativeParameterValue(parameter) {
  switch (parameter.type) {
    case 'number':
      return 1;
    case 'boolean':
      return 'f';
    case 'string':
      return 'foo'
    default:
      throw new Error(`Unrecognized parameter type: "${parameter.type}"`);
  }
}

function formatExamples(type) {
  let markdown = ''
  let didMarkdown;

  if (type.examples.markdown) {
    didMarkdown = true;
    markdown += makeString(6, `
      ##### Markdown

      \`\`\`
      ${type.examples.markdown}
      \`\`\``);
  }

  markdown += (didMarkdown ? '\n\n' : '') + buildNative(type);

  return markdown;
}

function formatParameters(parameters) {
  if (!parameters) {
    return 'This type has no parameters.\n';
  }

  let markdown = '';
  let didRequired;

  if (parameters.required) {
    didRequired = true;
    markdown += '##### Required\n\n';

    for (const parameter of parameters.required) {
      markdown += `- \`${parameter.name}\` (${parameter.type}) - ${parameter.description}\n`;
    }
  }

  if (parameters.optional) {
    markdown += `${didRequired ? '\n' : ''}##### Optional\n\n`;

    for (const parameter of parameters.optional) {
      markdown += `- \`${parameter.name}\` (${parameter.type}) - ${parameter.description}\n`;
    }
  }

  return markdown;
}

function makeString(spaces, string) {
  return string
    .split('\n')
    .map(line => line.replace(new RegExp(`^ {${spaces}}`), ''))
    .join('\n')
    .trim();
}
